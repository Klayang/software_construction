###### Objectives

1. Able to use a grammar with a parser generator, to parse a seq into a tree

2. Able to convert the parse tree into a useful data structure

    

###### Parser Generators

- A *parser generator* takes a grammar as input, and automatically generates a *parser*

- A *parser* takes a seq of chars, and tries to match the seq against the grammar

    

###### Parser

- A *parser* first produces a tree, expanding productions to match the given seq
  
  - The root of the tree is the root nonterminal of the grammar
  
  - Each node will expand into one production of the grammar

- Then the *parser* will translate the tree into a value of a recursive data type
  
  - It's used to represent expressions in a language, like `HTML`, `Java`, etc
  
  - Such a recursive abstract data type is called an *abstract syntax tree* (`AST`)

    

###### ParserLib

In 6.031, we are going to use [ParserLib](http://6031.mit.edu/parserlib/3.2.0/doc/), a *parser generator* for Java

- Each rule consists of a name, a `::=`, its definition, terminated by a semicolon (`;`)

- The `ParserLib` grammar can also include Java-style comments, single & multi line

- The `ParserLib` is case-insensitive concerning *nonterminal* names (all lowercase)

- *Terminal*s are quoted strings, or *regex*es. It'd either be quoted or enclosed:
  
  - In character class brackets (i.e., `'a'|'b'|'c'` or `[a-c]`)

- Good practice to put the rule for `root` nonterminal first in the grammar file
  
  - But not essential. Need to tell the parser which'd be the `root`:
  
  - When the *parser* is generated by the *generator*

    

###### A ParserLib Grammar Example

Here's the grammar of `HTML` we used in last lecture:

```c
html ::= ( italic | normal ) * ;
italic ::= '<i>' html '</i>' ;
normal ::= text ; 
text ::= [^<>]+ ;  /* a string of 1 or more chars that are not < or > */
```

    

###### Whitespace (1 / 3)

Consider the grammar shown below:

```c
expr ::= sum ;
sum ::= primary ('+' primary)* ;
primary ::= number | '(' sum ')' ;
number ::= [0-9]+ ;
```

    

###### Whitespace (2 / 3)

- The grammar'll accept an expression like `1+(3+4)`, but will reject a similar one 
  
  - If any whitespace within

- We'd modify the grammar to allow whitespace around `+`, by modifying `sum`
  
  ```c
  sum ::= primary (whitespace* '+' whitespace* primary)* ;
  whitespace ::= [ \t\r\n]+ ;
  ```

- However, this can be cubersome when we met a more complicated grammar
  
  - `ParserLib` allows a shorthand to indicate what'd be skipped

    

###### Whitespace (3 / 3)

```c
// the IntegerExpression grammar
@skip whitespace {
    expr ::= sum ;
    sum ::= primary ('+' primary)* ;
    primary ::= number | '(' sum ')' ;
}
whitespace ::= [ \t\r\n]+ ;
number ::= [0-9]+ ;
```

- `@skip whitespace` indicates 0 or more matches to the `whitespace`'d be ignored:
  
  - Before and after each terminal, nonterminal, and char-class 
  
  - On the righthand side of `expr`, `sum`, and `primary`

- From the point of view of grammar matching, these 3 rules effectively become:
  
  ```c
  expr ::= whitespace* sum whitespace* ;
  sum ::= whitespace* primary whitespace* (whitespace* '+' whitespace*
          primary whitespace*)* whitespace* ;
  primary ::= whitespace* number whitespace* | whitespace* '('  
              whitespace* sum whitespace* ')' whitespace* ;
  ```

    

###### Generating the Parser (1 / 2)

3 steps need to be followed if you want to apply `ParseLib` to generate a parser

- First, import the `ParseLib` library
  
  ```java
  import edu.mit.eecs.parserlib.*;
  ```

- Second, define an `enum` that contains all *nonterminal*s in your grammar
  
  ```java
  private static enum IntegerGrammar {
      EXPR, SUM, PRIMARY, NUMBER, WHITESPACE
  }
  ```

- Lastly, create a parser by calling its `compile` static factory method
  
  ```java
  Parser<IntegerGrammar> parser = 
      Parser.compile(new File("src/intexpr/IntegerExpression.g"),
                     IntegerGrammar.EXPR);
  ```
  
  - `IntegerExpression.g` should be the grammar of the parser

    

###### Generating the Parser (2 / 2)

- The code opens the file `IntegerExpression.g`, compiles it into a `Parser` object

- The 2nd arg specifies the name of the *nonterminal* as the root of the grammar

- Note the `Parser` is a generic type parameterized by the `IntegerGrammar` enum

    

###### Calling the Parser (1 / 2)

Now we can pass an input string to parse

- The parser has a method called `parse` that takes in the text to be parsed

- The text could be in the form of a `String`, `InputStream`, `File` or `Reader`

- It will generate a `ParseTree` (also a generic parameterized by the enum)

    

###### Calling the Parser (2 / 2)

```java
ParseTree<IntegerGrammar> tree = parser.parse("54+(2+ 89)");
```

```java
System.out.println(tree.toString()); // for debugging, can print the tree
```

```java
Visualizer.showInBrowser(tree); // can visualize the tree in a browser
```

    

###### Traversing the Parse Tree (1 / 2)

- Now we're going to translate the tree into a recursive abstract data type

- The `ParseTree` class has 4 major methods, 3 of which are the fundamental:
  
  <img src="file:///C:/Users/yangs/AppData/Roaming/marktext/images/2024-03-27-03-49-41-image.png" title="" alt="" width="541">

- Additionally, can query for all children that match a particular production
  
  <img src="file:///C:/Users/yangs/AppData/Roaming/marktext/images/2024-03-27-03-51-51-image.png" title="" alt="" width="550">

    

###### Traversing the Parse Tree (2 / 2)

Can write a recursive function to print nodes in a `ParseTree`, with proper identation

```java
/**
 * Traverse a parse tree, indenting to make it easier to read.
 * @param node   parse tree to print.
 * @param indent indentation to use.
 */
static void printNodes(ParseTree<IntegerGrammar> node, String indent) {
    System.out.println(indent + node.name() + ":" + node.text());
    for (ParseTree<IntegerGrammar> child: node.children()){
        printNodes(child, indent + "  ");
    }
}
```

<img title="" src="file:///C:/Users/yangs/AppData/Roaming/marktext/images/2024-03-27-03-55-46-image.png" alt="" width="160">    <img title="" src="file:///C:/Users/yangs/AppData/Roaming/marktext/images/2024-03-27-03-56-03-image.png" alt="" width="307">  <img title="" src="file:///C:/Users/yangs/AppData/Roaming/marktext/images/2024-03-27-03-56-25-image.png" alt="" width="158">

    

###### Constructing an Abstract Syntax Tree (1 / 2)

Here's the definition of the recursive data type to represent integer expressions

```c
IntegerExpression = Number(n:int)
    + Plus(left:IntegerExpression, right:IntegerExpression)
```

- When a recursive data type represents a language this way, it's called an `AST`

- By contrast, the `ParseTree` object we created is called a *concrete syntax tree*
  
  - As it contains more about how the expr is represented in actual chars

- e.g., `2+2`, `((2)+(2))`, `0002+0002` would each produce a different `CST`
  
  - But would all correspond to the same `AST`: `Plus(Number(2), Number(2))`

    

###### Constructing an Abstract Syntax Tree (2 / 2)

Here's a recursive function that walks `ParseTree` to produce an `IntegerExpression`

```java
/**
 * Convert a parse tree into an abstract syntax tree.
 * 
 * @param parseTree constructed according to the grammar
 * @return abstract syntax tree corresponding to parseTree
 */
private static IntegerExpression makeAbstractSyntaxTree
(final ParseTree<IntegerGrammar> parseTree) {
```

```java
switch (parseTree.name()) {
  case EXPR: // expr ::= sum;
  {
    final ParseTree<IntegerGrammar> child = parseTree.children().get(0);
    return makeAbstractSyntaxTree(child);
  }
```

```java
  case SUM: // sum ::= primary ('+' primary)*;
  {
    final List<ParseTree<IntegerGrammar>> children =parseTree.children();
    IntegerExpression expression = makeAbstractSyntaxTree(
        children.get(0));
    for (int i = 1; i < children.size(); ++i) {
      expression = new Plus(expression, 
        makeAbstractSyntaxTree(children.get(i)));
    }
    return expression;
  }
```

```java
  case PRIMARY: // primary ::= number | '(' sum ')';
  {
    final ParseTree<IntegerGrammar> child = parseTree.children().get(0);
    // check which alternative (number or sum) was actually matched
    switch (child.name()) {
      case NUMBER:
        return makeAbstractSyntaxTree(child);
      case SUM:
        return makeAbstractSyntaxTree(child); // in this case, the same
      default:
        throw new AssertionError("should never get here");
     }
   }
```

```java
  case NUMBER: // number ::= [0-9]+;
  {
    final int n = Integer.parseInt(parseTree.text());
    return new Number(n);
  }
```

```java
  default:
    throw new AssertionError("should never get here");
  }
}
```

    

###### Handling Errors

Several things can go wrong when parsing:

- Your grammar file may not exist. The `compile` method will throw an `IOException`

- The grammar has a syntax error.  `compile` will throw `UnableToParseException`

- The string you are trying to parse may not be parseable with the grammar
  
  - The `parse` method will throw an `UnableToParseException`

    

###### Left Recursion Limitation

- ParserLib works by generating a top-down *Recursive Descent Parser*

- Thus, it'd get stuck in parsing when the grammar is a *left-recursive* one
  
  ```c
  sum ::= number | sum '+' number ;
  number ::= [0-9]+ ;
  ```

- Can solve this by eliminating left recursion:
  
  ```c
  sum ::= (number '+')* number ;
  number ::= [0-9]+ ;
  ```
